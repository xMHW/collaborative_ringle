{"version":3,"sources":["modules/ApiHelper.js","modules/usedidmounteffect.js","components/Card.js","App.js","reportWebVitals.js","index.js"],"names":["ApiHelper","url","jwtToken","method","body","includes","bearer","header","headers","JSON","stringify","fetch","then","res","json","result","error","success","useDidMountEffect","func","deps","didMount","useRef","useEffect","current","Card","uuid","currentCard","findPrevCard","findNextCard","createdNewCardAtTree","setCurrentCard","deleteCurrentCardFromTree","setBackSpace","backSpace","mergePending","setMergePending","cardCreated","setCardCreated","goUp","setGoUp","socket","setSocket","useState","EditorState","createEmpty","editorState","setEditorState","today","Date","time","setTime","userId","useParams","setCard","textDifference","setTextDifference","setCursorDifference","cursorRef","DEFAULT_URL","contentState","getCurrentContent","rawContentState","convertToRaw","emit","delta","id","objectId","handler","deltamap","receivedContentState","convertFromRaw","currentSelectionState","getSelection","receivedEditorState","getAnchorOffset","getFocusOffset","set","currentContent","on","off","now","getHours","getMinutes","getSeconds","updateData","console","log","checkTextDifference","originalState","changedState","originalContent","changedContent","originalText","getPlainText","originalCharacterMetadata","getFirstBlock","getCharacterList","changedText","changedCharacterMetadata","checkCursorDifference","originalSelectionState","changedSelectionState","originalStartOffset","getStartOffset","changedStartOffset","originalFocusOffset","changedFocusOffset","focus","selectionState","length","mergedSelectionState","merge","focusOffset","anchorOffset","hasFocus","acceptSelection","moveFocusToEnd","focusKey","getFocusKey","mergedContentState","mergeBlockToContentState","newCardRaw","mergedEditorState2","createWithContent","getData","a","_id","response","parsedContent","parse","content","defaultEditorState","newCard","newCardEditorState","newCardContentState","newCardRawToString","created","updater","raw","rawToString","mergingBlock","getBlockMap","lastBlock","getLastBlock","newBlock","mergeBlockToAnotherBlock","ContentState","createFromBlockArray","originalBlock","ContentBlock","key","getKey","text","getText","concat","characterList","depth","getDepth","data","className","onKeyDown","evt","keyCode","contentLength","start","mergeBlock","anchorOffSet","getLength","goingDown","firstBlock","modifiedContentState","modifiedEditorState","undo","splitedBlocks","Modifier","splitBlock","newContentState","newEditorState","onChange","editState","ref","App","tree","setTree","goingUp","setGoingUp","treeDifference","setTreeDifference","treeCardCount","setTreeCardCount","getTree","checkTreeDifference","s","io","disconnect","cards","validateTree","allCards","map","i","indexOf","indexOfSplice","splice","updateTree","page","actionType","index","createdCard","createdId","newTree","copiedTree","style","padding","width","backgroundColor","maxWidth","borderRadius","display","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","basename","exact","path","component","document","getElementById"],"mappings":"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","file":"static/js/main.f10c8031.chunk.js","sourcesContent":["import fetch from 'isomorphic-unfetch'\n\nexport function ApiHelper(url, jwtToken = null, method = 'GET', body = null){\n    if (url.includes('undefined')){\n        return\n    }\n    let bearer = null\n    if (jwtToken){\n        bearer = 'Bearer ' + jwtToken \n    }\n    let header = null\n    if (body) {\n        header = {\n            method: method,\n            headers: {\n                'Authorization': bearer,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(body)\n        }\n    } else{\n        header = {\n            method: method,\n            headers: {\n                'Authorization': bearer,\n                'COntent-Type': 'application/json'\n            },\n        }\n    }\n    return fetch(url, header)\n        .then(res => res.json())\n        .then((result) => {\n            return result\n        }, (error) => ({\n            success: false,\n            error\n        }))\n}\n\n\n\n","import React, { useEffect, useRef } from 'react';\n\nconst useDidMountEffect = (func, deps) => {\n    const didMount = useRef(false);\n\n    useEffect(() => {\n        if (didMount.current) func();\n        else didMount.current = true;\n    }, deps);\n}\n\nexport default useDidMountEffect;\n","import React, {useState, useEffect, useRef} from 'react';\nimport {Editor, EditorState, convertToRaw, convertFromRaw, Modifier, SelectionState, ContentBlock, ContentState, genKey} from 'draft-js';\nimport {useParams} from \"react-router-dom\";\nimport {ApiHelper} from '../modules/ApiHelper'; \nimport useDidMountEffect from '../modules/usedidmounteffect';\n\nconst Card = ({\n  uuid, currentCard, findPrevCard, findNextCard, createdNewCardAtTree,\n   setCurrentCard, deleteCurrentCardFromTree, setBackSpace, backSpace,\n   mergePending, setMergePending, cardCreated, setCardCreated, goUp, setGoUp,\n   socket, setSocket,\n}) => {\n    const [editorState, setEditorState] = useState(() => \n        EditorState.createEmpty(),\n    );\n    // const [editorStateHistory, setEditorStateHistory] = useState([]);\n    var today = new Date();\n    const [time, setTime] = useState(); // created에 들어갈 시간 데이터\n    const { userId } = useParams(); //현재 페이지에 접속한 이용자 파라미터\n    const [card, setCard] = useState(); //현재 커서가 있는 카드의 content text\n    // const [uuid, setUuid] = useState(uuid); //현재 커서가 있는 카드의 uuid, 엔터 클릭시 생성된 카드의 uuid\n    const [hasEnded, setHasEnded] = useState(false); // 커서의 위치가 끝이면, 변경됨을 알려줌\n    const [textDifference, setTextDifference] = useState(false);\n    const [cursorDifference, setCursorDifference] = useState(false);\n    const cursorRef = useRef();\n\n    const DEFAULT_URL = \"http://54.180.147.138\"\n\n    //socket loading!\n    \n\n    const onChange = (editState) => {\n      console.log(checkTextDifference(editorState, editState));\n      if(checkTextDifference(editorState, editState)){\n        setTextDifference(true);\n      }\n      if(checkCursorDifference(editorState, editState)){\n        setCursorDifference(true);\n      }\n      setEditorState(editState);\n      // updateData(uuid);\n      setCurrentCard(uuid);\n    }\n\n    useEffect(() => {\n      if (socket == null || editorState == null || textDifference == false) return;\n      const contentState = editorState.getCurrentContent();\n      const rawContentState = convertToRaw(contentState);\n      socket.emit(\"send-changes\", {delta: rawContentState, id: userId, objectId: uuid});\n      setTextDifference(false);\n    }, [socket, editorState, textDifference]);\n\n    useEffect(() => {\n      if (socket == null || editorState == null) return;\n      const handler = (deltamap) => {\n        if(deltamap[\"id\"] == userId) return;\n        if(deltamap[\"objectId\"] != uuid) return;\n        const receivedContentState = convertFromRaw(deltamap[\"delta\"]);\n        const currentSelectionState = editorState.getSelection();\n        const currentAnchorOffset = currentSelectionState.getAnchorOffset();\n        const currentFocusOffset = currentSelectionState.getFocusOffset();\n        // const receivedSelectionState = currentSelectionState.set({anchorOffset: (currentAnchorOffset + 1), focusOffset: (currentFocusOffset + 1)});\n        const receivedEditorState = EditorState.set(editorState, {currentContent: receivedContentState});\n        // const receivedEditorState = EditorState.createWithContent(receivedContentState);\n        setEditorState(receivedEditorState);\n      };\n      socket.on(\"receive-changes\", handler);\n\n      return () => {\n        socket.off(\"receive-changes\", handler);\n      }\n    }, [socket, editorState]);\n\n    //editorState History에 기록을 남길 최대 개수를 100개로 제한하기 위해서 setEditorStateHistory를 그냥 사용하지 않고, 개수체크해서 길이를 30아래로 유지하도록 합시다.\n    // const addHistory = (editorState) => {\n    //   if (editorStateHistory.length === 30) {\n    //     editorStateHistory.pop();\n    //     editorStateHistory.splice(0,0,editorState);\n    //     return;\n    //   }\n    //   editorStateHistory.splice(0,0,editorState);\n    // }\n    \n    useDidMountEffect(() => {\n      // console.log(convertToRaw(editorState.getCurrentContent()).blocks[0])\n      var now = today.getHours() + ':' + today.getMinutes() + ':' + today.getSeconds();\n      setTime(now);\n      updateData(uuid);\n      console.log(editorState.getSelection(), uuid);\n    }, [editorState]);\n    \n    //text difference check! --> check in every onChange(), 만약에 텍스트 변화(스타일)가 있다면, True를 리턴해줄 것임!\n    const checkTextDifference = (originalState, changedState) => {\n      const originalContent = originalState.getCurrentContent();\n      const changedContent = changedState.getCurrentContent();\n      const originalText = originalContent.getPlainText();\n      const originalCharacterMetadata = originalContent.getFirstBlock().getCharacterList();\n      const changedText = changedContent.getPlainText();\n      const changedCharacterMetadata = changedContent.getFirstBlock().getCharacterList();\n      if(originalText != changedText) return true; //만약에 텍스트가 다르다면! 둘은 다름\n      if(originalCharacterMetadata != changedCharacterMetadata) return true; //만약에 스타일이 다르다면! 둘은 다름\n      return false; //둘 다 동일하다면, 둘은 같음\n    }\n\n    //cursor difference check! --> check in every onChange(), 만약에 커서 위치의 변화가 있다면, True를 리턴해줄 것임!\n    const checkCursorDifference = (originalState, changedState) => {\n      const originalSelectionState = originalState.getSelection();\n      const changedSelectionState = changedState.getSelection();\n      const originalStartOffset = originalSelectionState.getStartOffset();\n      const changedStartOffset = changedSelectionState.getStartOffset();\n      const originalFocusOffset = originalSelectionState.getFocusOffset();\n      const changedFocusOffset = changedSelectionState.getFocusOffset();\n      if(originalStartOffset != changedStartOffset) return true; //시작위치가 다르다면 둘은 다름\n      if(originalFocusOffset != changedFocusOffset) return true; //포커스위치가 다르다면 둘은 다름\n      return false; //둘 다 동일하다면, 둘은 동일함\n    }\n    \n    useDidMountEffect(() => {\n      if(currentCard == uuid) {\n        if(cursorRef.current){\n          cursorRef.current.focus();\n          // console.log(editorState.getSelection().getHasFocus());\n          if(cardCreated) {\n            const contentState = editorState.getCurrentContent();\n            const selectionState = editorState.getSelection();\n            const length = contentState.getPlainText().length;\n            const mergedSelectionState = selectionState.merge({\n              focusOffset: length,\n              anchorOffset: length,\n              hasFocus: true,\n            });\n            setEditorState(EditorState.acceptSelection(editorState, mergedSelectionState));\n            setCardCreated(false);\n          }\n          if(backSpace){\n            setEditorState(EditorState.moveFocusToEnd(editorState));\n            if(mergePending){\n              const contentState = editorState.getCurrentContent();\n              const selectionState = editorState.getSelection();\n              const focusKey = selectionState.getFocusKey();\n              const length = contentState.getPlainText().length;\n              const mergedContentState = mergeBlockToContentState(contentState, mergePending);\n              const newCardRaw = convertToRaw(mergedContentState);\n              const mergedEditorState2 = EditorState.createWithContent(convertFromRaw(newCardRaw))\n              const mergedSelectionState = selectionState.merge({\n                focusKey: focusKey,\n                focusOffset: length,\n                anchorOffset: length,\n                hasFocus: true,\n              })\n              setEditorState(EditorState.acceptSelection(mergedEditorState2, mergedSelectionState));\n              setMergePending(null);\n            }\n            setBackSpace(false);\n          }\n          if(goUp){\n            setEditorState(EditorState.moveFocusToEnd(editorState));\n            setGoUp(false);\n          }\n        }\n      }\n    },[currentCard])\n\n\n    useEffect(() => {\n      if(cardCreated) return;\n      getData(uuid);\n    }, [])\n  \n    const getData = async (uuid) => {\n      const response = await ApiHelper(`${DEFAULT_URL}/card/find`, null, 'POST',{\n        _id: uuid,\n      })\n      // console.log(uuid)\n      // console.log(response)\n      setCard(response)\n      if (response){\n        // console.log(response.content)\n        const parsedContent = JSON.parse(response.content)\n        const defaultEditorState = EditorState.createWithContent(convertFromRaw(parsedContent))\n        setEditorState(defaultEditorState)  \n      }else{\n        // console.log(\"No Response so default empty editor state returned\")\n      }\n    }\n    //위의 카드로 올라갈때의 설정\n    const goingUp = () => {\n      const selectionState = editorState.getSelection();\n      //start는 현재 카드에서의 커서의 위치 반환(텍스트의 index와 동일)\n      let start = selectionState.getStartOffset();\n      if (start === 0){\n        //현재 카드줄에 텍스트가 없다면\n        // if(!currentContent.hasText()){\n        //   findPrevCard(uuid, 'delete');\n        //   //currentCard의 uuid를 위의 카드값으로 변경\n        // }else{\n        //   findPrevCard(uuid);\n        // }\n        findPrevCard(uuid);\n      }\n    }\n    //아래의 카드로 내려갈때의 설정\n    const goingDown = () => {\n      const currentContent = editorState.getCurrentContent();\n      //현재 카드에 적혀있는 텍스트의 길이\n      const length = currentContent.getLastBlock().getLength();\n      const selectionState = editorState.getSelection();\n      //현재 카드에 있는 커서의 위치\n      let start = selectionState.getStartOffset();\n      //현재 커서 위치가 카드줄의 마지막이라면\n      if (start === length) {\n        findNextCard(uuid);\n      }\n      // if(length === start){\n      //   console.log('ended');\n      //   setHasEnded(Math.random());\n      // }else{\n      //   console.log('Not ended yet');\n      //   setHasEnded(false);\n      // }\n    }\n\n// 백스페이스 key = backspace, keyCode = 8\n\n    //키를 누를때 반응하는 함수\n    const onKeyDown = (evt) => {\n      // console.log(\"In Key Down\")\n      // console.log(evt.keyCode)\n      //백스페이스를 눌렀을 때\n      if (evt.keyCode === 8){\n        // 커서 위치가 맨 처음이면서 동시에 카드에 들어있는 내용이 아예없다면! 지워버려야죠\n        const contentState = editorState.getCurrentContent();\n        const contentLength = contentState.getPlainText().length;\n        const selectionState = editorState.getSelection();\n        const start = selectionState.getFocusOffset();\n        const mergeBlockMap = contentState.getBlockMap();\n        const mergeBlock = contentState.getFirstBlock();\n        const anchorOffSet = selectionState.getAnchorOffset();\n        if (start === 0) {\n          if (contentLength === 0) {\n            setBackSpace(true); //BackSpace로 이동할 때에는 위의 Card의 맨 끝으로 가야하기 위해서 선언한 State입니다. 위의 Card렌더링시에 BackSpace가 True이면 커서를 맨 끝으로 설정해 준 후에,\n            deleteCurrentCardFromTree(uuid);\n          }\n          else if (anchorOffSet != 0){\n            // console.log('anchor')\n            return\n          }\n          //카드에 들어있는 내용이 있다면, 위의 줄과 Merge해줘야 합니다.\n          else{\n            setBackSpace(true);\n            setMergePending(mergeBlock);\n            deleteCurrentCardFromTree(uuid);\n          }\n        }\n      }\n      if (evt.key === \"ArrowUp\"){\n        goingUp()\n        console.log(\"arrow up\")\n        return\n      }\n      if (evt.key === \"ArrowDown\"){\n        goingDown()\n        console.log(\"arrow down\")\n        return\n      }\n      if (evt.key === \"ArrowLeft\"){\n        const contentState = editorState.getCurrentContent();\n        const focusPosition = editorState.getSelection().getFocusOffset();\n        if (focusPosition === 0){\n          console.log(\"Arrow left\");\n          findPrevCard(uuid);\n        }\n      }\n      if (evt.key === \"ArrowRight\"){\n        const contentState = editorState.getCurrentContent();\n        const focusPosition = editorState.getSelection().getFocusOffset();\n        const contentLength = contentState.getPlainText().length;\n        if (focusPosition === contentLength){\n          console.log(\"Arrow right\");\n          findNextCard(uuid);\n        }\n      }\n      //탭을 눌렀을 때 -> 탭만 vs 쉬프트_탭\n      if (evt.key === \"Tab\"){\n        // setCurrentCard()\n      }\n      //엔터를 눌렀을 때\n      if (evt.keyCode === 13){\n        //새로운 카드를 생성해야함\n        //먼저 하나의 카드에 다음 줄로 넘어가는 것을 롤백해야함.\n        const contentState = editorState.getCurrentContent();\n        const focusPosition = editorState.getSelection().getFocusOffset();\n        const contentLength = contentState.getPlainText().length;\n        if(focusPosition == contentLength){\n          console.log(\"newCard!!!!!!\")\n          const firstBlock = contentState.getFirstBlock();\n          const modifiedContentState = ContentState.createFromBlockArray([firstBlock]);\n          const modifiedEditorState = EditorState.createWithContent(modifiedContentState);\n          setEditorState(modifiedEditorState);\n          setCardCreated(true);\n          newCard();\n          // setEditorState(EditorState.undo(editorState));\n        }\n        else{\n          setEditorState(EditorState.undo(editorState));\n          const selectionState = editorState.getSelection();\n          const splitedBlocks = Modifier.splitBlock(contentState, selectionState);\n          const modifiedContentState = ContentState.createFromBlockArray([splitedBlocks.getFirstBlock()]);\n          const modifiedEditorState = EditorState.createWithContent(modifiedContentState);\n          setEditorState(modifiedEditorState);\n          const newContentState = ContentState.createFromBlockArray([splitedBlocks.getLastBlock()]);\n          const newEditorState = EditorState.createWithContent(newContentState);\n          newCard(newEditorState);\n        }\n        // setEditorState(editorStateHistory[1]);\n        //커서 위치도 옯겨가야함!\n      }\n    }\n\n    //새로운, 빈, 카드 데이터 생성\n    const newCard = async (newCardEditorState = EditorState.createEmpty()) => {\n      // const newCardEditorState = EditorState.createEmpty();\n      const newCardContentState = newCardEditorState.getCurrentContent();\n      const newCardRaw = convertToRaw(newCardContentState);\n      const newCardRawToString = JSON.stringify(newCardRaw);\n      const response = await ApiHelper(`${DEFAULT_URL}/card/create`, null, 'POST', {\n        content: newCardRawToString, //엔터를 누르는 곳 뒤에 텍스트가 있다면, \n        created: time,\n        updater: userId,\n      })\n      // console.log(\"new Card\");\n      // console.log(response)\n      //새로운 카드의 id 로 uuid 업데이트\n      createdNewCardAtTree(response._id);\n      setCurrentCard(response._id);\n      // console.log(response._id)\n    }\n\n    //카드 데이터 셋 생성\n    const createData = async () => {\n        const contentState = editorState.getCurrentContent();\n        const raw = convertToRaw(contentState);\n        const rawToString = JSON.stringify(raw);\n        const response = await ApiHelper(`${DEFAULT_URL}/card/create`, null, 'POST', {\n            content: rawToString,\n            created: time,\n            updater: userId,\n          }\n          )\n        // console.log(editorState.getCurrentContent());\n        console.log(convertFromRaw(raw))\n        // console.log(convertToRaw(newEditorState.getCurrentContent()));\n        console.log(\"Saving\")\n        if (response){\n          console.log(response)\n        }\n    }\n\n    //카드 텍스트 업데이트\n    const updateData = async (uuid) => {\n        const contentState = editorState.getCurrentContent();\n        // console.log('update data');\n        // console.log(contentState.getPlainText());\n        const raw = convertToRaw(contentState);\n        const rawToString = JSON.stringify(raw);\n        const response = await ApiHelper(`${DEFAULT_URL}/card/update`, null, 'POST', {\n            _id: uuid,\n            content: rawToString,\n            created: time,\n            updater: userId,\n          }\n        )\n        // console.log(\"Updating\");\n        // console.log(time);\n        if (response){\n          // console.log(response)\n        }\n    }\n    \n    //카드 데이터셋 삭제\n    const deleteData = async () => {\n      const response = await ApiHelper(`${DEFAULT_URL}/card/delete`,null,'POST', {\n        _id: uuid,\n      })\n      console.log(response)\n    }\n    //ContentBlock 한개만 기존 contentState에 Merge하는 함수, 문제점이 있음! -> 기존에 contentState에 BlockMap에 추가해주며, 결과적으로 다음줄로 새로운 블럭이 나타납니다.\n    const mergeBlockToContentState = (contentState, mergingBlock) => {\n      const blockMap = contentState.getBlockMap();\n      const lastBlock = contentState.getLastBlock();\n      const newBlock = mergeBlockToAnotherBlock(lastBlock, mergingBlock);\n      const newContentState = ContentState.createFromBlockArray([newBlock]);\n      return newContentState;\n    }\n\n    //수정중인 함수-> 하나의 contentBlock에 다른 contentBlock의 내용을 가져와서 Merge하는 함수\n    const mergeBlockToAnotherBlock = (originalBlock, mergingBlock) => {\n      const newBlock = new ContentBlock({\n        key: originalBlock.getKey(),\n        text: originalBlock.getText().concat(mergingBlock.getText()),\n        characterList: originalBlock.getCharacterList(),\n        depth: originalBlock.getDepth(),\n        data: originalBlock.getData(),\n      });\n      return newBlock\n    }\n\n    // const selectionInitializedEditorState = () => {\n    //   const newSelectionState = new SelectionState({\n    //     hasFocus: true,\n    //   });\n    //   const newEditorState = EditorState.createEmpty();\n    //   const initializedEditorState = EditorState.forceSelection(newEditorState, newSelectionState);\n    //   return initializedEditorState;\n    // }\n\n\n    return (\n        <div className = \"cards\" onKeyDown={onKeyDown}>\n          <Editor\n          editorState={editorState}\n          onChange={onChange}\n          ref={cursorRef}\n        />\n        </div>\n    );\n  }\n  export default Card;\n  \n  // <div onClick = {deleteData}> click to delete</div>\n  // <div onClick = {createData}> click to save</div>\n  // <Editor editorState={editorState} onChange = {setEditorState}/>\n  // ref={editorRef}\n  // <br/>\n  // <div onClick = {updateData}> click to update</div>\n  // <div onClick = {deleteData}> click to delete</div>\n","import React, {useEffect, useRef, useState} from 'react';\nimport './App.css';\nimport {useParams} from \"react-router-dom\";\nimport {ApiHelper} from './modules/ApiHelper.js';\nimport Card from './components/Card.js';\nimport { io } from 'socket.io-client';\nimport useDidMountEffect from './modules/usedidmounteffect';\n\n\nconst SOCKET_URL = \"http://54.180.147.138:5000\"\nconst DEFAULT_URL = \"http://54.180.147.138\"\n// const SOCKET_URL = \"http://54.180.147.138:5000\"\n\nconst App = () => {\n  const [tree, setTree] = useState([]);\n  const [currentCard, setCurrentCard] = useState(null);\n  const [load, setLoad] = useState(false);\n  const [locRefs, setlocRefs] = useState([]);\n  const {userId} = useParams();\n  const [backSpace, setBackSpace] = useState(false);\n  const [mergePending, setMergePending] = useState(null);\n  const [cardCreated, setCardCreated] = useState(false);\n  const [goingUp, setGoingUp] = useState(false);\n  const [socket, setSocket] = useState();\n  const [treeDifference, setTreeDifference] = useState(false);\n  const [treeCardCount, setTreeCardCount] = useState(0);\n\n\n  useEffect(() => {\n    getTree();\n  }, []);\n\n  useEffect(() => {\n    if(checkTreeDifference(tree.length)) setTreeDifference(true);\n    setTreeCardCount(tree.length);\n  }, [tree]);\n\n  const checkTreeDifference = (length) => {\n    if(treeCardCount != length) return true;\n    return false;\n  };\n\n  useEffect(() => {\n    const s = io(SOCKET_URL);\n    setSocket(s);\n\n    return () => {\n      s.disconnect();\n    }\n  },[]);\n\n  useDidMountEffect(() => {\n    if (socket == null || tree == null || treeDifference == false) return;\n    socket.emit(\"send-tree-changes\", {delta: tree, id: userId});\n    setTreeDifference(true);\n  }, [socket, tree, treeDifference]);\n\n  useDidMountEffect(() => {\n    if (socket == null || tree == null) return;\n    const handler = (deltamap) => {\n      if(deltamap[\"id\"] == userId) return;\n      setTree(deltamap[\"delta\"]);\n    };\n    socket.on(\"receive-tree-changes\", handler);\n  }, [socket, tree]);\n\n  const createLoc = async () => {\n    const response = await ApiHelper(`${DEFAULT_URL}/loc/create`, null, 'POST', {\n      refs: [],\n    })\n  }\n\n  //아무런 정보가 없을 때, 트리/카드 하나 생성하도록?\n  const createTree = async () => {\n    const response = await ApiHelper(`${DEFAULT_URL}/tree/create`, null, 'POST', {\n      cards: [],\n      page: 0,\n    })\n  }\n\n  //트리 데이터 서버를 통해 받아오기, tree데이터는 uuid만 어레이로 저장\n  const getTree = async () => {\n    const response = await ApiHelper(`${DEFAULT_URL}/tree/find/all`, null, 'GET', null)\n    // console.log(response)\n    setTree(response[0].cards)\n    // console.log(tree)\n  }\n\n  const validateTree = async (tree) => {\n    const allCards = await ApiHelper(`${DEFAULT_URL}/card/find/all`, null, 'GET', null)\n    // console.log(allCards);\n    let result = allCards.map(({_id}) => _id)\n    // console.log(result)\n    for (var i = 0; i < tree.length; i++){\n      if (result.indexOf(tree[i]) === -1){\n        let indexOfSplice = tree.indexOf(tree[i]);\n        tree.splice(indexOfSplice, 1);\n        // console.log(\"Splicing\", tree[i]);\n      }\n      // console.log(\"validating cards while updating\")\n    }\n    const validatedTree = tree;\n    setTree(validatedTree)\n  }\n\n  const updateTree = async (page, tree) => {\n    //page와 cards 받아오기\n    validateTree(tree);\n    const response = await ApiHelper(`${DEFAULT_URL}/tree/update`, null, 'POST', {\n      page: page,\n      cards: [\"608b3f2157e25818a1d3ff16\",\"608b3f3557e25818a1d3ff17\"],\n    })\n    // console.log(\"updating tree\")\n    // console.log(response)\n  }\n\n  // console.log(tree)\n\n  const findPrevCard = (uuid, actionType) => {\n    const index = tree.indexOf(uuid)\n    if (index === -1){\n      return\n    }\n    if (index === 0){\n      return\n    }\n    //본 카드 위에있는 카드의 uuid가져오기\n    setCurrentCard(tree[index-1]);\n    setGoingUp(true);\n\n    // if(actionType === \"delete\"){\n    //   const copied = [...tree]\n    //   copied.splice(index, 1);\n    //   setTree(copied);\n    //   //tree 업데이트 됬음을 알려서 -> !!!!!!!!!!!!!!!!!!\n    // }\n  }\n\n  const findNextCard = (uuid) => {\n    const index = tree.indexOf(uuid)\n    if (index === -1){\n      console.log(\"That card uuid is Invalid!!!!!!!\")\n      return\n    }\n    if (!tree[index+1]){\n      console.log(\"There is no Card After this one!!!!!\")\n      return\n    }\n    //본 카드 다음에 있는 카드의 uuid 가져오기\n    console.log(\"Nothing went wrong!\")\n    setCurrentCard(tree[index + 1]);\n  }\n\n  const createdCard = (createdId) => {\n    const index = tree.indexOf(currentCard);\n    let newTree = []\n    if(index === -1){\n      newTree = [\n        ...tree, createdId\n      ]\n      setTree(newTree)\n    }else{\n      const copiedTree = [...tree]\n      copiedTree.splice(index + 1, 0, \n        createdId\n      );\n      newTree= copiedTree;\n      setTree(newTree);\n    }\n\n    updateTree(1, newTree);\n    //트리가 업데이트 되었다는 것을 알려줘야 함!!!!!!!!!\n  }\n  \n  const deleteCurrentCardFromTree = () => {\n    const index = tree.indexOf(currentCard);\n    setCurrentCard(tree[index-1]);\n    let newTree = []\n    if(index === -1){\n      return\n    }else{\n      const copiedTree = [...tree]\n      copiedTree.splice(index, 1);\n      newTree = copiedTree;\n      setTree(newTree)\n    }\n    updateTree(1, newTree);\n  }\n\n\n\n\n  return <>\n  <div style = {{padding:16, width:1100, backgroundColor: 'white', maxWidth:1100, borderRadius:8, display: 'inline-block'}}>\n    {\n      tree.map((id) => <Card key={id}\n      // initContentState = {obj.initContentState}\n      uuid = {id}\n      currentCard = {currentCard}\n      findPrevCard = {findPrevCard}\n      findNextCard = {findNextCard}\n      createdNewCardAtTree = {createdCard}\n      setCurrentCard = {setCurrentCard}\n      deleteCurrentCardFromTree = {deleteCurrentCardFromTree}\n      setBackSpace = {setBackSpace}\n      backSpace = {backSpace}\n      mergePending = {mergePending}\n      setMergePending = {setMergePending}\n      cardCreated = {cardCreated}\n      setCardCreated = {setCardCreated}\n      goUp = {goingUp}\n      setGoUp = {setGoingUp}\n      socket = {socket}\n      setSocket = {setSocket}\n    />)\n    }\n    </div>\n    \n    \n    </>\n}\n\nexport default App;\n// createNewCard={add} \n// findPrevCard={findPrevCard}\n// findNextCard={findNextCard}\n// updateId={updateId}\n// updateData={updateData}\n// initContentState = {obj.initContentState}\n\n// {/* <div onClick = {createTree}>TreeCreate</div> */}\n/* <div className = \"superFancyBlockQuote\" ref = {thisRef} contentEditable = {true} placeholder = \"write\">\n    \n    </div> */\n\n// <div onClick = {printRef}>  Print Typed Content</div>\n// <div onClick = {updating}>  Update Ref</div>\n// <div onClick = {removing}>  Remove Ref</div>\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// import Card from './components/Card2'\nimport reportWebVitals from './reportWebVitals';\nimport {\n  BrowserRouter as Router,\n  HashRouter,\n  Route,\n  Switch,\n} from 'react-router-dom';\n\nReactDOM.render(\n  <HashRouter basename=\"/\">\n    <Switch>\n      <Route exact path=\"/:userId\" component={App}/>\n    </Switch>\n  </HashRouter>,\n  document.getElementById('root')\n  );\n  \n  // <Route exact path=\"/\" component={App}/>\n  // If you want to start measuring performance in your app, pass a function\n  // to log results (for example: reportWebVitals(console.log))\n  // or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\n  reportWebVitals();\n  \n  // <React.StrictMode>\n  //   <Router>\n  //     <Switch>\n  //       <Route exact path='/:userId' component={App}/>\n  //     </Switch>\n  //   </Router>\n  // </React.StrictMode>,\n  //   document.getElementById('root')"],"sourceRoot":""}