{"version":3,"sources":["modules/ApiHelper.js","modules/usedidmounteffect.js","components/Card.js","App.js","reportWebVitals.js","index.js"],"names":["ApiHelper","url","jwtToken","method","body","includes","bearer","header","headers","JSON","stringify","fetch","then","res","json","result","error","success","useDidMountEffect","func","deps","didMount","useRef","useEffect","current","Card","uuid","currentCard","findPrevCard","findNextCard","createdNewCardAtTree","setCurrentCard","deleteCurrentCardFromTree","setBackSpace","backSpace","mergePending","setMergePending","cardCreated","setCardCreated","goUp","setGoUp","socket","setSocket","useState","EditorState","createEmpty","editorState","setEditorState","today","Date","time","setTime","userId","useParams","setCard","textDifference","setTextDifference","setCursorDifference","AnchorOffset","FocusOffset","oldOffsets","setOldOffsets","cursorRef","DEFAULT_URL","contentState","getCurrentContent","rawContentState","convertToRaw","selectionState","getSelection","getAnchorOffset","getFocusOffset","offsetDelta","AnchorDelta","FocusDelta","emit","delta","id","objectId","handler","deltamap","myOffset","targetOffset","targetDelta","receivedContentState","convertFromRaw","currentSelectionState","currentAnchorOffset","changedSelectionState","changedOffset","checkBetweenOffset","set","changeSelectionState","targetAnchorOffset","targetFocusOffset","checkOffsetBetween","receivedEditorState","currentContent","receivedEditorStateWithSelection","acceptSelection","on","off","now","getHours","getMinutes","getSeconds","updateData","checkTextDifference","originalState","changedState","originalContent","changedContent","originalText","getPlainText","originalCharacterMetadata","getFirstBlock","getCharacterList","changedText","changedCharacterMetadata","checkCursorDifference","originalSelectionState","originalStartOffset","getStartOffset","changedStartOffset","originalFocusOffset","changedFocusOffset","focus","length","mergedSelectionState","merge","focusOffset","anchorOffset","hasFocus","moveFocusToEnd","focusKey","getFocusKey","mergedContentState","mergeBlockToContentState","newCardRaw","mergedEditorState2","createWithContent","getData","a","_id","response","parsedContent","parse","content","defaultEditorState","newCard","newCardEditorState","newCardContentState","newCardRawToString","created","updater","raw","rawToString","mergingBlock","getBlockMap","lastBlock","getLastBlock","newBlock","mergeBlockToAnotherBlock","ContentState","createFromBlockArray","originalBlock","ContentBlock","key","getKey","text","getText","concat","characterList","depth","getDepth","data","className","onKeyDown","evt","keyCode","contentLength","start","mergeBlock","anchorOffSet","console","log","getLength","goingDown","firstBlock","modifiedContentState","modifiedEditorState","undo","splitedBlocks","Modifier","splitBlock","newContentState","newEditorState","onChange","editState","oldSelectionState","oldAnchorOffset","oldFocusOffset","ref","App","tree","setTree","goingUp","setGoingUp","treeDifference","setTreeDifference","treeCardCount","setTreeCardCount","getTree","checkTreeDifference","s","io","disconnect","cards","validateTree","allCards","map","i","indexOf","indexOfSplice","splice","updateTree","page","actionType","index","createdCard","createdId","newTree","copiedTree","style","padding","width","backgroundColor","maxWidth","borderRadius","display","reportWebVitals","onPerfEntry","Function","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","exact","path","component","document","getElementById"],"mappings":"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","file":"static/js/main.e32cb388.chunk.js","sourcesContent":["import fetch from 'isomorphic-unfetch'\n\nexport function ApiHelper(url, jwtToken = null, method = 'GET', body = null){\n    if (url.includes('undefined')){\n        return\n    }\n    let bearer = null\n    if (jwtToken){\n        bearer = 'Bearer ' + jwtToken \n    }\n    let header = null\n    if (body) {\n        header = {\n            method: method,\n            headers: {\n                'Authorization': bearer,\n                'Content-Type': 'application/json'\n            },\n            body: JSON.stringify(body)\n        }\n    } else{\n        header = {\n            method: method,\n            headers: {\n                'Authorization': bearer,\n                'COntent-Type': 'application/json'\n            },\n        }\n    }\n    return fetch(url, header)\n        .then(res => res.json())\n        .then((result) => {\n            return result\n        }, (error) => ({\n            success: false,\n            error\n        }))\n}\n\n\n\n","import React, { useEffect, useRef } from 'react';\n\nconst useDidMountEffect = (func, deps) => {\n    const didMount = useRef(false);\n\n    useEffect(() => {\n        if (didMount.current) func();\n        else didMount.current = true;\n    }, deps);\n}\n\nexport default useDidMountEffect;\n","import React, {useState, useEffect, useRef} from 'react';\nimport {Editor, EditorState, convertToRaw, convertFromRaw, Modifier, SelectionState, ContentBlock, ContentState, genKey} from 'draft-js';\nimport {useParams} from \"react-router-dom\";\nimport {ApiHelper} from '../modules/ApiHelper'; \nimport useDidMountEffect from '../modules/usedidmounteffect';\n\nconst Card = ({\n  uuid, currentCard, findPrevCard, findNextCard, createdNewCardAtTree,\n   setCurrentCard, deleteCurrentCardFromTree, setBackSpace, backSpace,\n   mergePending, setMergePending, cardCreated, setCardCreated, goUp, setGoUp,\n   socket, setSocket,\n}) => {\n    const [editorState, setEditorState] = useState(() => \n        EditorState.createEmpty(),\n    );\n    // const [editorStateHistory, setEditorStateHistory] = useState([]);\n    var today = new Date();\n    const [time, setTime] = useState(); // created에 들어갈 시간 데이터\n    const { userId } = useParams(); //현재 페이지에 접속한 이용자 파라미터\n    const [card, setCard] = useState(); //현재 커서가 있는 카드의 content text\n    // const [uuid, setUuid] = useState(uuid); //현재 커서가 있는 카드의 uuid, 엔터 클릭시 생성된 카드의 uuid\n    const [hasEnded, setHasEnded] = useState(false); // 커서의 위치가 끝이면, 변경됨을 알려줌\n    const [textDifference, setTextDifference] = useState(false);\n    const [cursorDifference, setCursorDifference] = useState(false);\n    const [oldOffsets, setOldOffsets] = useState({AnchorOffset: 0, FocusOffset: 0});\n    const cursorRef = useRef();\n\n    const DEFAULT_URL = \"http://54.180.147.138\"\n\n    //socket loading!\n    \n\n    const onChange = (editState) => {\n      console.log(checkTextDifference(editorState, editState));\n      const oldSelectionState = editorState.getSelection();\n      const oldAnchorOffset = oldSelectionState.getAnchorOffset();\n      const oldFocusOffset = oldSelectionState.getFocusOffset();\n      setOldOffsets({AnchorOffset: oldAnchorOffset, FocusOffset: oldFocusOffset});\n      if(checkTextDifference(editorState, editState)){\n        setTextDifference(true);\n      }\n      if(checkCursorDifference(editorState, editState)){\n        setCursorDifference(true);\n      }\n      setEditorState(editState);\n      // updateData(uuid);\n      setCurrentCard(uuid);\n    }\n    //소켓을 통하여 변화가 있을 경우에 보내주는 것 -> 보낼 내용 contentState Raw화 한것, 변경한 userid, 변경한 object id, 변화 이전 업데이터의 커서 오프셋, 오프셋 변화량(나중 오프셋 - 이전 오프셋)\n    useEffect(() => {\n      if (socket == null || editorState == null || textDifference == false) return;\n      const contentState = editorState.getCurrentContent();\n      const rawContentState = convertToRaw(contentState);\n      const selectionState = editorState.getSelection();\n      const AnchorOffset = selectionState.getAnchorOffset();\n      const FocusOffset = selectionState.getFocusOffset();\n      const AnchorDelta = AnchorOffset - oldOffsets[\"AnchorOffset\"];\n      const FocusDelta = FocusOffset - oldOffsets[\"FocusOffset\"];\n      const offsetDelta = {AnchorDelta: AnchorDelta, FocusDelta: FocusDelta};\n      socket.emit(\"send-changes\", {delta: rawContentState, id: userId, objectId: uuid, oldOffsets: oldOffsets, offsetDelta: offsetDelta});\n      setTextDifference(false);\n    }, [socket, editorState, textDifference]);\n\n    const checkOffsetDelta = (myOffset, targetOffset, targetDelta) => {\n      if(myOffset<=targetOffset) return myOffset;\n      return myOffset + targetDelta;\n    }\n\n    const checkOffsetBetween = (myOffset, targetAnchorOffset, targetFocusOffset) => {\n      if(targetAnchorOffset<myOffset && myOffset<targetFocusOffset) return targetAnchorOffset;\n      if(targetFocusOffset<myOffset && myOffset<targetAnchorOffset) return targetFocusOffset;\n      return null;\n    }\n\n    const changeSelectionState = (changedOffset, checkBetweenOffset, selectionState) => {\n      if(checkBetweenOffset) {\n        const changedSelectionState = selectionState.set('focusOffset', checkBetweenOffset);\n        const changedSelectionStateWithAnchor = changedSelectionState.set('anchorOffset', checkBetweenOffset);\n        return changedSelectionStateWithAnchor;\n      }\n      const changedSelectionState = selectionState.set('focusOffset', changedOffset);\n      const changedSelectionStateWithAnchor = changedSelectionState.set('anchorOffset', changedOffset);\n      return changedSelectionStateWithAnchor;\n    }\n\n    useEffect(() => {\n      if (socket == null || editorState == null) return;\n      const handler = (deltamap) => {\n        if(deltamap[\"id\"] == userId) return;\n        if(deltamap[\"objectId\"] != uuid) return;\n        const receivedContentState = convertFromRaw(deltamap[\"delta\"]);\n        const currentSelectionState = editorState.getSelection();\n        const currentAnchorOffset = currentSelectionState.getAnchorOffset(); // 일단 focus, anchor가 동일하다 가정(블럭 선택 고려 x)\n        // const currentFocusOffset = currentSelectionState.getFocusOffset();\n        const changedAnchorOffset = checkOffsetDelta(currentAnchorOffset, deltamap[\"oldOffsets\"][\"AnchorOffset\"], deltamap[\"offsetDelta\"][\"AnchorDelta\"]);\n        // const changedFocusOffset = checkOffsetDelta(currentFocusOffset, deltamap[\"oldOffsets\"][\"FocusOffset\"], deltamap[\"offsetDelta\"][\"FocusDelta\"]);\n        const checkBetweenOffset = checkOffsetBetween(currentAnchorOffset, deltamap[\"oldOffsets\"][\"AnchorOffset\"], deltamap[\"oldOffsets\"][\"FocusOffset\"]);\n        const changedSelectionState = changeSelectionState(changedAnchorOffset, checkBetweenOffset, currentSelectionState);\n        const receivedEditorState = EditorState.set(editorState, {currentContent: receivedContentState});\n        const receivedEditorStateWithSelection = EditorState.acceptSelection(receivedEditorState, changedSelectionState);\n        // const receivedEditorState = EditorState.createWithContent(receivedContentState);\n        setEditorState(receivedEditorStateWithSelection);\n      };\n      socket.on(\"receive-changes\", handler);\n\n      return () => {\n        socket.off(\"receive-changes\", handler);\n      }\n    }, [socket, editorState]);\n\n    //editorState History에 기록을 남길 최대 개수를 100개로 제한하기 위해서 setEditorStateHistory를 그냥 사용하지 않고, 개수체크해서 길이를 30아래로 유지하도록 합시다.\n    // const addHistory = (editorState) => {\n    //   if (editorStateHistory.length === 30) {\n    //     editorStateHistory.pop();\n    //     editorStateHistory.splice(0,0,editorState);\n    //     return;\n    //   }\n    //   editorStateHistory.splice(0,0,editorState);\n    // }\n    \n    useDidMountEffect(() => {\n      // console.log(convertToRaw(editorState.getCurrentContent()).blocks[0])\n      var now = today.getHours() + ':' + today.getMinutes() + ':' + today.getSeconds();\n      setTime(now);\n      updateData(uuid);\n    }, [editorState]);\n    \n    //text difference check! --> check in every onChange(), 만약에 텍스트 변화(스타일)가 있다면, True를 리턴해줄 것임!\n    const checkTextDifference = (originalState, changedState) => {\n      const originalContent = originalState.getCurrentContent();\n      const changedContent = changedState.getCurrentContent();\n      const originalText = originalContent.getPlainText();\n      const originalCharacterMetadata = originalContent.getFirstBlock().getCharacterList();\n      const changedText = changedContent.getPlainText();\n      const changedCharacterMetadata = changedContent.getFirstBlock().getCharacterList();\n      if(originalText != changedText) return true; //만약에 텍스트가 다르다면! 둘은 다름\n      if(originalCharacterMetadata != changedCharacterMetadata) return true; //만약에 스타일이 다르다면! 둘은 다름\n      return false; //둘 다 동일하다면, 둘은 같음\n    }\n\n    //cursor difference check! --> check in every onChange(), 만약에 커서 위치의 변화가 있다면, True를 리턴해줄 것임!\n    const checkCursorDifference = (originalState, changedState) => {\n      const originalSelectionState = originalState.getSelection();\n      const changedSelectionState = changedState.getSelection();\n      const originalStartOffset = originalSelectionState.getStartOffset();\n      const changedStartOffset = changedSelectionState.getStartOffset();\n      const originalFocusOffset = originalSelectionState.getFocusOffset();\n      const changedFocusOffset = changedSelectionState.getFocusOffset();\n      if(originalStartOffset != changedStartOffset) return true; //시작위치가 다르다면 둘은 다름\n      if(originalFocusOffset != changedFocusOffset) return true; //포커스위치가 다르다면 둘은 다름\n      return false; //둘 다 동일하다면, 둘은 동일함\n    }\n    \n    useDidMountEffect(() => {\n      if(currentCard == uuid) {\n        if(cursorRef.current){\n          cursorRef.current.focus();\n          // console.log(editorState.getSelection().getHasFocus());\n          if(cardCreated) {\n            const contentState = editorState.getCurrentContent();\n            const selectionState = editorState.getSelection();\n            const length = contentState.getPlainText().length;\n            const mergedSelectionState = selectionState.merge({\n              focusOffset: length,\n              anchorOffset: length,\n              hasFocus: true,\n            });\n            setEditorState(EditorState.acceptSelection(editorState, mergedSelectionState));\n            setCardCreated(false);\n          }\n          if(backSpace){\n            setEditorState(EditorState.moveFocusToEnd(editorState));\n            if(mergePending){\n              const contentState = editorState.getCurrentContent();\n              const selectionState = editorState.getSelection();\n              const focusKey = selectionState.getFocusKey();\n              const length = contentState.getPlainText().length;\n              const mergedContentState = mergeBlockToContentState(contentState, mergePending);\n              const newCardRaw = convertToRaw(mergedContentState);\n              const mergedEditorState2 = EditorState.createWithContent(convertFromRaw(newCardRaw))\n              const mergedSelectionState = selectionState.merge({\n                focusKey: focusKey,\n                focusOffset: length,\n                anchorOffset: length,\n                hasFocus: true,\n              })\n              setEditorState(EditorState.acceptSelection(mergedEditorState2, mergedSelectionState));\n              setMergePending(null);\n            }\n            setBackSpace(false);\n          }\n          if(goUp){\n            setEditorState(EditorState.moveFocusToEnd(editorState));\n            setGoUp(false);\n          }\n        }\n      }\n    },[currentCard])\n\n\n    useEffect(() => {\n      if(cardCreated) return;\n      getData(uuid);\n    }, [])\n  \n    const getData = async (uuid) => {\n      const response = await ApiHelper(`${DEFAULT_URL}/card/find`, null, 'POST',{\n        _id: uuid,\n      })\n      // console.log(uuid)\n      // console.log(response)\n      setCard(response)\n      if (response){\n        // console.log(response.content)\n        const parsedContent = JSON.parse(response.content)\n        const defaultEditorState = EditorState.createWithContent(convertFromRaw(parsedContent))\n        setEditorState(defaultEditorState)  \n      }else{\n        // console.log(\"No Response so default empty editor state returned\")\n      }\n    }\n    //위의 카드로 올라갈때의 설정\n    const goingUp = () => {\n      const selectionState = editorState.getSelection();\n      //start는 현재 카드에서의 커서의 위치 반환(텍스트의 index와 동일)\n      let start = selectionState.getStartOffset();\n      if (start === 0){\n        //현재 카드줄에 텍스트가 없다면\n        // if(!currentContent.hasText()){\n        //   findPrevCard(uuid, 'delete');\n        //   //currentCard의 uuid를 위의 카드값으로 변경\n        // }else{\n        //   findPrevCard(uuid);\n        // }\n        findPrevCard(uuid);\n      }\n    }\n    //아래의 카드로 내려갈때의 설정\n    const goingDown = () => {\n      const currentContent = editorState.getCurrentContent();\n      //현재 카드에 적혀있는 텍스트의 길이\n      const length = currentContent.getLastBlock().getLength();\n      const selectionState = editorState.getSelection();\n      //현재 카드에 있는 커서의 위치\n      let start = selectionState.getStartOffset();\n      //현재 커서 위치가 카드줄의 마지막이라면\n      if (start === length) {\n        findNextCard(uuid);\n      }\n      // if(length === start){\n      //   console.log('ended');\n      //   setHasEnded(Math.random());\n      // }else{\n      //   console.log('Not ended yet');\n      //   setHasEnded(false);\n      // }\n    }\n\n// 백스페이스 key = backspace, keyCode = 8\n\n    //키를 누를때 반응하는 함수\n    const onKeyDown = (evt) => {\n      // console.log(\"In Key Down\")\n      // console.log(evt.keyCode)\n      //백스페이스를 눌렀을 때\n      if (evt.keyCode === 8){\n        // 커서 위치가 맨 처음이면서 동시에 카드에 들어있는 내용이 아예없다면! 지워버려야죠\n        const contentState = editorState.getCurrentContent();\n        const contentLength = contentState.getPlainText().length;\n        const selectionState = editorState.getSelection();\n        const start = selectionState.getFocusOffset();\n        const mergeBlockMap = contentState.getBlockMap();\n        const mergeBlock = contentState.getFirstBlock();\n        const anchorOffSet = selectionState.getAnchorOffset();\n        if (start === 0) {\n          if (contentLength === 0) {\n            setBackSpace(true); //BackSpace로 이동할 때에는 위의 Card의 맨 끝으로 가야하기 위해서 선언한 State입니다. 위의 Card렌더링시에 BackSpace가 True이면 커서를 맨 끝으로 설정해 준 후에,\n            deleteCurrentCardFromTree(uuid);\n          }\n          else if (anchorOffSet != 0){\n            // console.log('anchor')\n            return\n          }\n          //카드에 들어있는 내용이 있다면, 위의 줄과 Merge해줘야 합니다.\n          else{\n            setBackSpace(true);\n            setMergePending(mergeBlock);\n            deleteCurrentCardFromTree(uuid);\n          }\n        }\n      }\n      if (evt.key === \"ArrowUp\"){\n        goingUp()\n        console.log(\"arrow up\")\n        return\n      }\n      if (evt.key === \"ArrowDown\"){\n        goingDown()\n        console.log(\"arrow down\")\n        return\n      }\n      if (evt.key === \"ArrowLeft\"){\n        const contentState = editorState.getCurrentContent();\n        const focusPosition = editorState.getSelection().getFocusOffset();\n        if (focusPosition === 0){\n          console.log(\"Arrow left\");\n          findPrevCard(uuid);\n        }\n      }\n      if (evt.key === \"ArrowRight\"){\n        const contentState = editorState.getCurrentContent();\n        const focusPosition = editorState.getSelection().getFocusOffset();\n        const contentLength = contentState.getPlainText().length;\n        if (focusPosition === contentLength){\n          console.log(\"Arrow right\");\n          findNextCard(uuid);\n        }\n      }\n      //탭을 눌렀을 때 -> 탭만 vs 쉬프트_탭\n      if (evt.key === \"Tab\"){\n        // setCurrentCard()\n      }\n      //엔터를 눌렀을 때\n      if (evt.keyCode === 13){\n        //새로운 카드를 생성해야함\n        //먼저 하나의 카드에 다음 줄로 넘어가는 것을 롤백해야함.\n        const contentState = editorState.getCurrentContent();\n        const focusPosition = editorState.getSelection().getFocusOffset();\n        const contentLength = contentState.getPlainText().length;\n        if(focusPosition == contentLength){\n          console.log(\"newCard!!!!!!\")\n          const firstBlock = contentState.getFirstBlock();\n          const modifiedContentState = ContentState.createFromBlockArray([firstBlock]);\n          const modifiedEditorState = EditorState.createWithContent(modifiedContentState);\n          setEditorState(modifiedEditorState);\n          setCardCreated(true);\n          newCard();\n          // setEditorState(EditorState.undo(editorState));\n        }\n        else{\n          setEditorState(EditorState.undo(editorState));\n          const selectionState = editorState.getSelection();\n          const splitedBlocks = Modifier.splitBlock(contentState, selectionState);\n          const modifiedContentState = ContentState.createFromBlockArray([splitedBlocks.getFirstBlock()]);\n          const modifiedEditorState = EditorState.createWithContent(modifiedContentState);\n          setEditorState(modifiedEditorState);\n          const newContentState = ContentState.createFromBlockArray([splitedBlocks.getLastBlock()]);\n          const newEditorState = EditorState.createWithContent(newContentState);\n          newCard(newEditorState);\n        }\n        // setEditorState(editorStateHistory[1]);\n        //커서 위치도 옯겨가야함!\n      }\n    }\n\n    //새로운, 빈, 카드 데이터 생성\n    const newCard = async (newCardEditorState = EditorState.createEmpty()) => {\n      // const newCardEditorState = EditorState.createEmpty();\n      const newCardContentState = newCardEditorState.getCurrentContent();\n      const newCardRaw = convertToRaw(newCardContentState);\n      const newCardRawToString = JSON.stringify(newCardRaw);\n      const response = await ApiHelper(`${DEFAULT_URL}/card/create`, null, 'POST', {\n        content: newCardRawToString, //엔터를 누르는 곳 뒤에 텍스트가 있다면, \n        created: time,\n        updater: userId,\n      })\n      // console.log(\"new Card\");\n      // console.log(response)\n      //새로운 카드의 id 로 uuid 업데이트\n      createdNewCardAtTree(response._id);\n      setCurrentCard(response._id);\n      // console.log(response._id)\n    }\n\n    //카드 데이터 셋 생성\n    const createData = async () => {\n        const contentState = editorState.getCurrentContent();\n        const raw = convertToRaw(contentState);\n        const rawToString = JSON.stringify(raw);\n        const response = await ApiHelper(`${DEFAULT_URL}/card/create`, null, 'POST', {\n            content: rawToString,\n            created: time,\n            updater: userId,\n          }\n          )\n        // console.log(editorState.getCurrentContent());\n        console.log(convertFromRaw(raw))\n        // console.log(convertToRaw(newEditorState.getCurrentContent()));\n        console.log(\"Saving\")\n        if (response){\n          console.log(response)\n        }\n    }\n\n    //카드 텍스트 업데이트\n    const updateData = async (uuid) => {\n        const contentState = editorState.getCurrentContent();\n        // console.log('update data');\n        // console.log(contentState.getPlainText());\n        const raw = convertToRaw(contentState);\n        const rawToString = JSON.stringify(raw);\n        const response = await ApiHelper(`${DEFAULT_URL}/card/update`, null, 'POST', {\n            _id: uuid,\n            content: rawToString,\n            created: time,\n            updater: userId,\n          }\n        )\n        // console.log(\"Updating\");\n        // console.log(time);\n        if (response){\n          // console.log(response)\n        }\n    }\n    \n    //카드 데이터셋 삭제\n    const deleteData = async () => {\n      const response = await ApiHelper(`${DEFAULT_URL}/card/delete`,null,'POST', {\n        _id: uuid,\n      })\n      console.log(response)\n    }\n    //ContentBlock 한개만 기존 contentState에 Merge하는 함수, 문제점이 있음! -> 기존에 contentState에 BlockMap에 추가해주며, 결과적으로 다음줄로 새로운 블럭이 나타납니다.\n    const mergeBlockToContentState = (contentState, mergingBlock) => {\n      const blockMap = contentState.getBlockMap();\n      const lastBlock = contentState.getLastBlock();\n      const newBlock = mergeBlockToAnotherBlock(lastBlock, mergingBlock);\n      const newContentState = ContentState.createFromBlockArray([newBlock]);\n      return newContentState;\n    }\n\n    //수정중인 함수-> 하나의 contentBlock에 다른 contentBlock의 내용을 가져와서 Merge하는 함수\n    const mergeBlockToAnotherBlock = (originalBlock, mergingBlock) => {\n      const newBlock = new ContentBlock({\n        key: originalBlock.getKey(),\n        text: originalBlock.getText().concat(mergingBlock.getText()),\n        characterList: originalBlock.getCharacterList(),\n        depth: originalBlock.getDepth(),\n        data: originalBlock.getData(),\n      });\n      return newBlock\n    }\n\n    // const selectionInitializedEditorState = () => {\n    //   const newSelectionState = new SelectionState({\n    //     hasFocus: true,\n    //   });\n    //   const newEditorState = EditorState.createEmpty();\n    //   const initializedEditorState = EditorState.forceSelection(newEditorState, newSelectionState);\n    //   return initializedEditorState;\n    // }\n\n\n    return (\n        <div className = \"cards\" onKeyDown={onKeyDown}>\n          <Editor\n          editorState={editorState}\n          onChange={onChange}\n          ref={cursorRef}\n        />\n        </div>\n    );\n  }\n  export default Card;\n  \n  // <div onClick = {deleteData}> click to delete</div>\n  // <div onClick = {createData}> click to save</div>\n  // <Editor editorState={editorState} onChange = {setEditorState}/>\n  // ref={editorRef}\n  // <br/>\n  // <div onClick = {updateData}> click to update</div>\n  // <div onClick = {deleteData}> click to delete</div>\n","import React, {useEffect, useRef, useState} from 'react';\nimport './App.css';\nimport {useParams} from \"react-router-dom\";\nimport {ApiHelper} from './modules/ApiHelper.js';\nimport Card from './components/Card.js';\nimport { io } from 'socket.io-client';\nimport useDidMountEffect from './modules/usedidmounteffect';\n\n\nconst SOCKET_URL = \"http://54.180.147.138:5000\"\nconst DEFAULT_URL = \"http://54.180.147.138\"\n// const SOCKET_URL = \"http://54.180.147.138:5000\"\n\nconst App = () => {\n  const [tree, setTree] = useState([]);\n  const [currentCard, setCurrentCard] = useState(null);\n  const [load, setLoad] = useState(false);\n  const [locRefs, setlocRefs] = useState([]);\n  const {userId} = useParams();\n  const [backSpace, setBackSpace] = useState(false);\n  const [mergePending, setMergePending] = useState(null);\n  const [cardCreated, setCardCreated] = useState(false);\n  const [goingUp, setGoingUp] = useState(false);\n  const [socket, setSocket] = useState();\n  const [treeDifference, setTreeDifference] = useState(false);\n  const [treeCardCount, setTreeCardCount] = useState(0);\n\n\n  useEffect(() => {\n    getTree();\n  }, []);\n\n  useEffect(() => {\n    if(checkTreeDifference(tree.length)) setTreeDifference(true);\n    setTreeCardCount(tree.length);\n  }, [tree]);\n\n  const checkTreeDifference = (length) => {\n    if(treeCardCount != length) return true;\n    return false;\n  };\n\n  useEffect(() => {\n    const s = io(SOCKET_URL);\n    setSocket(s);\n\n    return () => {\n      s.disconnect();\n    }\n  },[]);\n\n  useDidMountEffect(() => {\n    if (socket == null || tree == null || treeDifference == false) return;\n    socket.emit(\"send-tree-changes\", {delta: tree, id: userId});\n    setTreeDifference(true);\n  }, [socket, tree, treeDifference]);\n\n  useDidMountEffect(() => {\n    if (socket == null || tree == null) return;\n    const handler = (deltamap) => {\n      if(deltamap[\"id\"] == userId) return;\n      setTree(deltamap[\"delta\"]);\n    };\n    socket.on(\"receive-tree-changes\", handler);\n  }, [socket, tree]);\n\n  const createLoc = async () => {\n    const response = await ApiHelper(`${DEFAULT_URL}/loc/create`, null, 'POST', {\n      refs: [],\n    })\n  }\n\n  //아무런 정보가 없을 때, 트리/카드 하나 생성하도록?\n  const createTree = async () => {\n    const response = await ApiHelper(`${DEFAULT_URL}/tree/create`, null, 'POST', {\n      cards: [],\n      page: 0,\n    })\n  }\n\n  //트리 데이터 서버를 통해 받아오기, tree데이터는 uuid만 어레이로 저장\n  const getTree = async () => {\n    const response = await ApiHelper(`${DEFAULT_URL}/tree/find/all`, null, 'GET', null)\n    // console.log(response)\n    setTree(response[0].cards)\n    // console.log(tree)\n  }\n\n  const validateTree = async (tree) => {\n    const allCards = await ApiHelper(`${DEFAULT_URL}/card/find/all`, null, 'GET', null)\n    // console.log(allCards);\n    let result = allCards.map(({_id}) => _id)\n    // console.log(result)\n    for (var i = 0; i < tree.length; i++){\n      if (result.indexOf(tree[i]) === -1){\n        let indexOfSplice = tree.indexOf(tree[i]);\n        tree.splice(indexOfSplice, 1);\n        // console.log(\"Splicing\", tree[i]);\n      }\n      // console.log(\"validating cards while updating\")\n    }\n    const validatedTree = tree;\n    setTree(validatedTree)\n  }\n\n  const updateTree = async (page, tree) => {\n    //page와 cards 받아오기\n    validateTree(tree);\n    const response = await ApiHelper(`${DEFAULT_URL}/tree/update`, null, 'POST', {\n      page: page,\n      cards: [\"608b3f2157e25818a1d3ff16\",\"608b3f3557e25818a1d3ff17\"],\n    })\n    // console.log(\"updating tree\")\n    // console.log(response)\n  }\n\n  // console.log(tree)\n\n  const findPrevCard = (uuid, actionType) => {\n    const index = tree.indexOf(uuid)\n    if (index === -1){\n      return\n    }\n    if (index === 0){\n      return\n    }\n    //본 카드 위에있는 카드의 uuid가져오기\n    setCurrentCard(tree[index-1]);\n    setGoingUp(true);\n\n    // if(actionType === \"delete\"){\n    //   const copied = [...tree]\n    //   copied.splice(index, 1);\n    //   setTree(copied);\n    //   //tree 업데이트 됬음을 알려서 -> !!!!!!!!!!!!!!!!!!\n    // }\n  }\n\n  const findNextCard = (uuid) => {\n    const index = tree.indexOf(uuid)\n    if (index === -1){\n      console.log(\"That card uuid is Invalid!!!!!!!\")\n      return\n    }\n    if (!tree[index+1]){\n      console.log(\"There is no Card After this one!!!!!\")\n      return\n    }\n    //본 카드 다음에 있는 카드의 uuid 가져오기\n    console.log(\"Nothing went wrong!\")\n    setCurrentCard(tree[index + 1]);\n  }\n\n  const createdCard = (createdId) => {\n    const index = tree.indexOf(currentCard);\n    let newTree = []\n    if(index === -1){\n      newTree = [\n        ...tree, createdId\n      ]\n      setTree(newTree)\n    }else{\n      const copiedTree = [...tree]\n      copiedTree.splice(index + 1, 0, \n        createdId\n      );\n      newTree= copiedTree;\n      setTree(newTree);\n    }\n\n    updateTree(1, newTree);\n    //트리가 업데이트 되었다는 것을 알려줘야 함!!!!!!!!!\n  }\n  \n  const deleteCurrentCardFromTree = () => {\n    const index = tree.indexOf(currentCard);\n    setCurrentCard(tree[index-1]);\n    let newTree = []\n    if(index === -1){\n      return\n    }else{\n      const copiedTree = [...tree]\n      copiedTree.splice(index, 1);\n      newTree = copiedTree;\n      setTree(newTree)\n    }\n    updateTree(1, newTree);\n  }\n\n\n\n\n  return <>\n  <div style = {{padding:16, width:1100, backgroundColor: 'white', maxWidth:1100, borderRadius:8, display: 'inline-block'}}>\n    {\n      tree.map((id) => <Card key={id}\n      // initContentState = {obj.initContentState}\n      uuid = {id}\n      currentCard = {currentCard}\n      findPrevCard = {findPrevCard}\n      findNextCard = {findNextCard}\n      createdNewCardAtTree = {createdCard}\n      setCurrentCard = {setCurrentCard}\n      deleteCurrentCardFromTree = {deleteCurrentCardFromTree}\n      setBackSpace = {setBackSpace}\n      backSpace = {backSpace}\n      mergePending = {mergePending}\n      setMergePending = {setMergePending}\n      cardCreated = {cardCreated}\n      setCardCreated = {setCardCreated}\n      goUp = {goingUp}\n      setGoUp = {setGoingUp}\n      socket = {socket}\n      setSocket = {setSocket}\n    />)\n    }\n    </div>\n    \n    \n    </>\n}\n\nexport default App;\n// createNewCard={add} \n// findPrevCard={findPrevCard}\n// findNextCard={findNextCard}\n// updateId={updateId}\n// updateData={updateData}\n// initContentState = {obj.initContentState}\n\n// {/* <div onClick = {createTree}>TreeCreate</div> */}\n/* <div className = \"superFancyBlockQuote\" ref = {thisRef} contentEditable = {true} placeholder = \"write\">\n    \n    </div> */\n\n// <div onClick = {printRef}>  Print Typed Content</div>\n// <div onClick = {updating}>  Update Ref</div>\n// <div onClick = {removing}>  Remove Ref</div>\n","const reportWebVitals = onPerfEntry => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\n\n// import Card from './components/Card2'\nimport reportWebVitals from './reportWebVitals';\nimport {\n  HashRouter as Router,\n  Route,\n  Switch,\n} from 'react-router-dom';\n\nReactDOM.render(\n  <React.StrictMode>\n    <Router>\n      <Switch>\n        <Route exact path=\"/:userId\" component={App}/>\n      </Switch>\n    </Router>\n  </React.StrictMode>,\n  document.getElementById('root')\n  );\n  \n  // <Route exact path=\"/\" component={App}/>\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}